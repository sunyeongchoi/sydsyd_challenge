import sys
input = sys.stdin.readline
T,W = map(int,input().split())
# 0번째 인덱스에 0 값을 넣어줌(0초에 떨어지는 자두는 0)
plums = [0]+[int(input()) for _ in range(T)]
dp=[[0]*(W+1) for _ in range(T+1)]
# i는 초,j는 이동 횟수: i초에 j번 이동했을 때 최댓값을 구하는 방법
for i in range(1,T+1):
    # i초동안 한번도 움직이지 않았을 때 먹은 자두
    dp[i][0] = dp[i-1][0] + 1 if plums[i]==1 else dp[i-1][0]
    # 이동 횟수를 1회부터 W회까지 움직이면서 체크
    for j in range(1,W+1):
        # 이동횟수가 시간보다 커지면 종료(1초에 최대 1번 이동할 수 있으니까)
        if j>i:break
        # j%2==0: 1번나무였다가 2번나무로 이동 다시 1번나무로 오려면 이동횟수가 2번.
        # 그래서 j%2==0이면 현재 위치는 1번나무인 것을 알 수 있다
        # 자두나무가 1번에서 떨어지고 이동한 현재위치와 일치하면 먹기
        if plums[i]==1 and j%2==0:
            # 1초 전에, 이미 이동해서 1번 자두나무였을 때(dp[i-1][j])와 2번나무(dp[i-1][j-1])여서 현재 이동했을때의 최댓값을
            # 비교해서 먹은 자두 최댓값을 넣어준다.
            # 결국 1초 전에 이동 한 번하거나 현재 이동은 한 번이므로 횟수는 같음
            dp[i][j] = max(dp[i-1][j],dp[i-1][j-1])+1
        # 자두나무가 2번에서 떨어지고 이동한 현재위치와 일치하면 먹기
        elif plums[i]==2 and j%2==1:
            dp[i][j] = max(dp[i-1][j],dp[i-1][j-1])+1
        # 자두가 떨어지는 나무와 현재위치가 엇갈려서 자두 못먹는 경우
        else:dp[i][j] = max(dp[i-1][j],dp[i-1][j-1])
# T초동안 먹은 자두 중 최댓값을 출력
print(max(dp[-1]))