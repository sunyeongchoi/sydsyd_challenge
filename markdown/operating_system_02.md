- # <데드락(DeadLock)>

  ### 데드락이란?

  - 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태(교착상태)
  - 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생
  - 응답없음 상태와 비슷(A프로세스는 B가 가진 자원이 있어야 동작 가능 → B작업을 기다림 → B프로세스 역시 A가 가진 자원이 있어야함 → A기다림 → 무한교착)
  - 시스템 자원에 대한 경쟁 도중에 발생할 수도 있고 프로세스간의 통신 과정에서 발생할 수 있다.

  ### 데드락 발생 조건

  4가지 모두 성립해야 발생(하나라도 성립하지 않으면 데드락 문제 해결 가능)

  1. 상호배제
     - 한번에 오직 1개의 프로세스만이 자원 접근 가능
  2. 점유대기
     - 최소한 한개의 자원을 가진 프로세스가 다른 프로세스 소유의 자원을 추가로 얻기위해 기다리는 것
  3. 비선점
     - 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음
  4. 순환대기
     - 연쇄적으로 자원을 기다리는 형태(1은 2를 기다리고, 2는 3을 기다리고 3은 1을 기다리는 것)

  ### 데드락 처리

  **교착상태를 예방 & 회피**

  1. 예방(Prevention)

  교착 상태 발생 조건 중 하나를 제거하면서 해결한다. (자원낭비 심함)

  - 상호배제 부정 : 여러 프로세스가 공유 자원 사용할 수 있도록 한다.
  - 점유대기 부정 : 프로세스 실행전 모필요한 든 자원을 할당
  - 비선점 부정 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납
  - 순환대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구

  1. 회피(avoidance)

  교착 생태 발생 시 피해나가는 방법

  은행원 알고리즘(Banker's Algorithm)

  - 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래함
  - 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 교착상태 회피
  - 안정 상태면 자원 할당, 아니면 다른 프로세스들이 자원 해지까지 대기

  ![](https://t1.daumcdn.net/cfile/tistory/242D124B5407E3830C?download)

  **교착상태를 탐지 & 회복**

  교착상태가 되도록 허용한 다음 회복시키는 방법

  1. 탐지(Detection)

  자원 할당 그래프를 통해 교착 상태를 탐지함

  자원 요청시, 탐지 알고리즘을 실행시켜 그에 대한 오버헤드 발생함

  1. 회복(Recovery)

  교착 상태 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복시키는 방법

  **프로세스 종료 방법**

  - 교착 상태의 프로세스를 모두 중지
  - 교착 상태가 제거될 때까지 하나씩 프로세스 중지

  **자원 선점 방법**

  - 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당(해당 프로세스 일시정지 시킴)
  - 우선순위가 낮은 프로세스나 수행 횟수 적은 프로세스 위주로 프로세스 자원 선점

  **교착 상태 무시**

  대부분의 시스템은 교착상태가 잘 발생하지 않으며, 교착상태 예방, 회피, 탐지, 복구하는 것은 비용이 많이 든다.

  # <경쟁상태(Race Condition)>

  ## 경쟁상태란?

  - 둘 이상의 입력이나 조작이 동시에 일어나 의도하지 않은 결과를 가져오는 경우를 말함
  - 프로세스들 끼리 하나의 자원을 갖기 위해 싸우는 것, 하나의 자원을 동시에 요청

  ## Race Condition이 발생하는 경우

  **1. 커널 작업을 수행하는 중에 인터럽트 발생**

  - 문제점 : 커널모드에서 데이터를 로드하여 작업을 수행하다가 인터럽트가 발생하여 같은 데이터를 조작하는 경우
  - 해결법 : 커널모드에서 작업을 수행하는 동안, 인터럽트를 disable 시켜 CPU 제어권을 가져가지 못하도록 한다.

  **2. 프로세스가 'System Call'을 하여 커널 모드로 진입하여 작업을 수행하는 도중 문맥교환이 발생할 때**

  - 문제점 : 프로세스1이 커널모드에서 데이터를 조작하는 도중, 시간이 초과되어 CPU제어권이 프로세스2로 넘어가 같은 데이터를 조작하는 경우 (프로세스2가 작업에 반영되지 않음)
  - 해결법 : 프로세스가 커널모드에서 작업을 하는 경우 시간이 초과되어도 CPU제어권이 다른 프로세스에게 넘어가지 않도록 함

  **3. 멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근할 때**

  - 문제점 : 멀티 프로세서 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우
  - 해결법 : 커널 내부에 있는 각 공유 데이터에 접근할 때마다, 그 데이터에 대한 lock/unlock 을 하는 방법

  # <세마포어와 뮤텍스>

  ## 개념

  - 세마포어
    - 공유된 자원의 데이터를 여러 프로세스가 접근하는 것을 막는 것
  - 뮤텍스
    - 공유된 자원의 데이터를 여러 쓰레드가 접근하는 것을 막는 것
  - Critical Section(임계구역):
    - 각 프로세스에서 공유 데이터를 액세스하는 프로그램 코드 부분
    - 여러 프로세스가 데이터 공유하며 수행될 때, 각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 부분
    - 한 프로세스가 임계구역을 수행할 때는 다른 프로세스가 접근하지 못하도록 해야한다
  - 세마포어 vs 뮤택스 차이점 :
    - 세마포어 - 동기화 대상이 하나 이상일 때 사용
    - 뮤택스 - 동기화 대상이 오직 하나뿐일 때 사용

  ### 세마포어 P, V 연산

  P : 임계 구역에 들어가지 전에 수행 (프로세스 진입 여부를 자원의 개수(S)를 통해 결정)

  V : 임계 구역에서 나올 때 수행 (자원 반납 알림, 대기중인 프로세스를 깨우는 신호)

  ```
  P(S);
  
  // --- 임계 구역 ---
  
  V(S);
  procedure P(S)   --> 최초 S값은 1임
      while S=0 do wait  --> S가 0면 1이 될때까지 기다려야 함
      S := S-1   --> S를 0로 만들어 다른 프로세스가 들어 오지 못하도록 함
  end P
  
  --- 임계 구역 ---
  
  procedure V(S) --> 현재상태는 S가 0임
      S := S+1   --> S를 1로 원위치시켜 해제하는 과정
  end V
  ```

  - 이를 통해, 한 프로세스가 P혹은 V를 수행하고 있는 동안 프로세스가 인터럽트 당하지 않게 된다.
  - P와 V를 사용하여 임계구역에 대한 상호배제 구현이 가능하게 되있다.

  # <페이징과 세그맨테이션>

  ## 개념

  - 가상 메모리 관리 기법

  - 페이징 :

    - 고정된 영역인 페이지로 분할

      (돼지를 모두 같은 단위로 잘라서 보관)

    - 프로세스를 일정한 단위로 잘라서 사용하자는 방식

  - 세그맨테이션 :

    - 가변적인 영역인 세그먼트로 분할

      (돼지를 부위별로 잘라서 보관)

    - 사용자의 필요에 의한 메모리

    - 사용자 관점의 가상메모리 관리 기법

    - 중요도/용도 에 따라 나눌 수 있어 보호와 공유에 용이

  ## 사용이유

  - 다중 프로그래밍 시스템에 여러 프로세스를 수용하기 위해 주기억장치를 동적 분할하는 메모리 관리 작업이 필요하기 때문
  - 메모리의 용량은 한정적이므로 여러 응용 프로그램의 사용을 위해 효율적인 메모리 관리 기법이 필요

  # <페이지 교체 알고리즘>

  ## 개념

  - 가상 메모리는 요구 페이지 기법을 통해 필요한 페이지만 메모리에 적재하고 사용하지 않는 부분은 그래도 둠
  - 하지만 필요한 페이지만 올려도 메모리 가득 참 —> 올라와있던 페이지가 사용이 다 된 후에도 자리만 차지
  - 메모리가 가득 차면, 추가로 페이지를 가져오기 위해서 안쓰는 페이지는 out하고, 해당 공간에 현재 필요한 페이지를 in시켜야함
  - 여기서 어떤 페이지를 out시켜야 할 지 정해야한다.
  - out 되는 페이지 == victim page
  - 기왕이면 수정되지 않는 페이지를 선택해야 함
  - ⇒ 이와같이 상황에 맞는 페이지 교체를 진행하기 위해 페이지 교체 알고리즘이 존재

  ## 종류

  ### 1. FIFO

  - 메모리에 먼저 올라온 페이지를 먼저 내보내는 알고리즘
  - 가장 간단한 방법
  - 초기화 코드(처음 프로세스 실행될 때 최초 초기화를 시키는 역할만 진행하고 다른 역할은 수행하지 않으므로, 메인 메모리에서 빼도 괜찮음)에서 적절한 방법

  ### 2. 최적(Optimal) 페이지 교체(OPT알고리즘)

  - 앞으로 가장 사용하지 않을 페이지를 가장 우선적으로 내보냄
  - FIFO에 비해 페이지 결함의 횟수를 많이 감소시킬 수 있음
  - 실질적으로 페이지가 앞으로 잘 사용되지 않을 것이라는 보장이 없기 때문에 수행하기 어려운 알고리즘

  ### 3. LRU(least-recentlly-used)

  - 최근에 사용하지 않은 페이지를 가장 먼저 내려보내는 알고리즘
  - OPT의 경우 미래 예측이지만, LRU의 경우는 과거를 보고 판단하므로 실질적으로 사용이 가능한 알고리즘
  - OPT보다는 페이지 결함이 더 일어날 수 있지만, **실제로 사용할 수 있는 페이지 교체 알고리즘에서는 가장 좋은 방법 중 하나**

  # <메모리(Memory)>

  ## 메모리 관리의 목표

  - 프로그래밍을 할 때 쉽게 메모리를 사용할 수 있도록 abstraction을 제공
  - 자원의 효율적 관리
  - 메모리 보호

  ![](https://t1.daumcdn.net/cfile/tistory/9950C73359C4A5E416)

  - base : 메모리에서 프로세스의 시작 위치
  - limit : 프로세스에게 할당된 메모리의 크기값
  - 즉, base ≤ 프로세스가 접근할 수 있는 공간 ≤ base + limit

  # <파일시스템(File System)>

  ## 개념

  - HDD나 SSD와 같은 2차 저장소에 저장을 하여 파일을 영구 보관하는 것
  - 컴퓨터에서 파일이나 자료를 쉽게 발견할 수 있도록, 유지 관리하는 방법
  - 저장매체에는 수많은 파일이 있기 때문에, 이런 파일들을 관리하는 방법

  ## 특징

  - 커널 영역에서 동작
  - 파일 CRUD 기능을 원활이 수행하기 위한 목적
  - 계층적 디렉터리 구조를 가짐
  - 디스크 파티션 별로 하나씩 둘 수 있음

  ## 역할

  - 파일 관리
  - 보조 저장소 관리
  - 파일 무결성 메커니즘
  - 접근 방법 제공

  ## 개발 목적

  - 하드디스크와 메인 메모리 속도차를 줄이기 위함
  - 파일 관리
  - 하드디스크 용량 효율적 이용

  ## 구조

  - 메타영역 : 데이터 영역에 기록된 파일의 이름, 위치, 크기, 시간정보, 삭제유무 등의 파일 정보
  - 데이터 영역 : 파일의 데이터