# 1. 운영체제란?

## 개념

- 사용자가 컴퓨터를 사용하기 위해 필요한 소프트웨어
- 일반적으로 컴퓨터를 사용하면서 실행한 모든 프로그램을 운영체제에서 관리/제어
- 프로그래머가 컴퓨터 하드웨어를 모르더라도 컴퓨터를 쉽게 만들 수 있도록 지원해주는 소프트웨어

![https://media.vlpt.us/images/min1378/post/62719f32-3006-4217-bbb3-29fe25967c0b/운영체제-1.png](https://media.vlpt.us/images/min1378/post/62719f32-3006-4217-bbb3-29fe25967c0b/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-1.png)

## 종류

- Windows
- Linux
- Mac OSX
- IOS

## 목적

- 컴퓨터를 잘 쓰기 위함
- 처리능력 향상, 응답시간의 최소화, 신뢰도 향상, 사용 가능도 향상

## 기능

- 

# 2. 프로세스&스레드

## 프로세스란?

- 자기자신만의 주소공간을 갖는 독립적인 실행 프로그램
- 메모리에 올라와 실행중인 프로그램 객체 자체
- 운영체제로부터 시스템 자원을 할당받는 작업의 단위

![https://gmlwjd9405.github.io/images/os-process-and-thread/process.png](https://gmlwjd9405.github.io/images/os-process-and-thread/process.png)

- 프로세스당 최소 1개의 스레드(메인스레드) 가짐
- 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.(통신 위해선 소켓등을 이용한 통신 방법 사용)

## 스레드란?

- 프로세스 내에서 실행되는 여러 흐름의 단위
- 하나의 실행 흐름 자체
- 하나의 프로세스 안에서 여러개의 태스킹을 동시에 실행하고 싶을 때 사용

![https://gmlwjd9405.github.io/images/os-process-and-thread/thread.png](https://gmlwjd9405.github.io/images/os-process-and-thread/thread.png)

- 프로세스는 자신만의 고유 공간과 자원을 할당받아 사용하는데 반해, 스레드는 다른 스레드와 공간, 자원을 공유하면서 사용

## 멀티 프로세스란?

- 두개 이상의 프로세스가 실행되는 것
- 장점
  - 자식 프로세스 중 하나에 문제가 발생하면 다른 영향이 확산되지 않음
- 단점
  - Context Switching 오버헤드
    - Context Switching 과정에서 캐쉬 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생
  - 하나의 프로그램에 속하는 프로세스들 사이의 변수를 공유할 수 없다.

## 멀티 스레드란?

- 하나의 프로세스에 여러 개의 스레드가 병행적으로 처리

![](https://t1.daumcdn.net/cfile/tistory/230B7D3359019EBE18)



- 장점
  - 자원의 효율성 증대
    - 시스템콜(프로세스를 생성하여 자원을 할당하는 과정)이 줄어들어 자원을 효율적으로 관리할 수 있다.
  - 시스템 처리량 증가
    - 스레드 사이의 작업량이 작아 Context Switching 이 빠르다.
  - 프로세스 내의 Stack영역을 제외한 모든 메모리를 공유하기 떄문에 통신의 부담이 적다.
- 단점
  - 자원을 공유하므로 동기화 문제가 발생
  - 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향받음
  - 설계/디버깅 까다로움

# 3. 프로세스의 주소 공간

- Code: 코드자체를 구성하는 메모리 영역(프로그램 명령)
- Data: 전역변수, 정적변수, 배열 등 (초기화된 데이터)
- Heap: 동적할당 시 사용 (new(), mallock() 등)
- Stack: 지역변수, 매개변수, 리턴값 (임시메모리 영역)

# 4. 인터럽트(Interrupt)

## 개념

- 프로그램을 실행하는 동중에 예기치 않은 상황이 발생할 경우 현재 실행중인 작업을 중단하고 발생괸 상황을 처리한 후 다시 실행중인 작업으로 복귀하는 것

## 인터럽트 종류

### 1. 외부 인터럽트

- 전원 이상 인터럽트 : 정전, 파워이상
- 기계 착오 인터럽트 : CPU의 기능적인 오류
- 입출력 인터럽트 : 입출력 데이터 이상
- 외부 신호 인터럽트 : 자원이 할당된 시간이 다 끝난 경우

### 2. 내부 인터럽트

- 잘못된 명령이나 잘못된 데이터를 사용할 때 발생(Trap이라 부름)

> 0으로 나누기 발생, 오버플로우, 명령어 잘못 사용한 경우 (Exception)

### 3.  소프트웨어 인터럽트(이거 뭔지 잘 모르겠음)

- 프로그램 처리 중 명령의 요청에 의해 발생한 것
  - 대표적 예) 감시 프로그램을 호출하는 SVC인터럽트
  - SVC인터럽트 - 사용자가 SVC명령을 써서 의도적으로 호출한 경우, 복잡한 입출력 처리를 해야하는 경우에 발생

## 인터럽트 동작 순서

1. 인터럽트 요청
2. 프로그램 실행 중단
3. 현재의 프로그램 상태 보존
4. 인터럽트 처리루틴 실행 : 인터럽트를 요청한 장치를 식별
5. 인터럽트 서비스루틴 실행 : 원인을 파악하고 실질적 작업 수행. 서비스 루틴 중 우선순위가 더 높은 인터럽트 발생시 재귀적으로 1~5를 수행
6. 상태복구
7. 중단된 프로그램 실행 재개

## 인터럽트 우선순위

전원이상 > 기계착오 > 외부신호 > 입출력 > 명령어 잘못 > 프로그램 검사 > SVC(SuperVisor Call)

# 5. 시스템 호출(System Call)

## 개념

- 응용프로그램에서 운영체제에게 어떠한 기능(시스템 자원)을 수행해달라고 하는 하나의 수단
- 커널 영역의 기능을 사용자 모드가 사용 가능하게, 즉 프로세스가 하드웨어에 직접 접근해서 필요한 기능을 사용할 수 있게 해준다.
- 처리방식
  - 사용자 프로세스가 시스템 콜을 요청하면 제어가 커널로 넘어옴(사용자 모드 →  커널모드)
  - 커널은 내부적으로 각각의 시스템 콜을 구분하기 위해 기능별로 고유번호를 할당하고 그 번호에 해당하는 제어루틴을 커널 내부에 정의
  - 커널은 요청받은 시스템 콜에 대응하는 기능번호를 확인
  - 커널은 그 번호에 맞는 서비스 루틴을 호출
  - 서비스 루틴을 모두 처리하고 나면 커널 모드에서 사용자 모드로 다시 전환

## 커널모드 / 사용자모드

- 커널모드 : 모든 시스템 메모리 접근 가능. 모든 CPU명령 실행 가능
- 사용자모드 : 사용자 애플리케이션 실행. 하드웨어 직접 접근 불가. System Call호출시 일시적으로 커널모드로 전환

## System Call을 사용하는 이유

- OS는 프로세스의 실행, 종료나 I/O작업등의 사용자가 함부로 사용하면 문제가 될 만한 명령들을 Privileged Instruction으로 분류하여 막아놓았다.
- 따라서 사용자들이 이와 같은 가능을 사용하기 위해서는 OS가 제공하는 System Call을 사용하여야 한다.

## 유형

- 프로세스 제어(fork, signal, load, wait time)
- 파일 조작(open, read, write, close)
- 장치 관리(request device, attach, detach)
- 메모리 관리(alloc, kmalloc, kfree)
- 통신 관련(socket, bind)

## System Call 수행과정

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FALlGh%2FbtquL0XgOow%2FqaDksq1AsUKrpZKEzSu0DK%2Fimg.png)



- 프로세스가 System Call을 호출하면 trap이 발생하여 kernel mode로 진입
- 그 후 요청이 들어온 System Call을 수행한 뒤 return-from-trap을 발생기켜 user mode로 돌아간다.

## 여기서 의문인점

- 시스템 콜을 사용한다는컨 프로그래밍 언어로 써서 사용한다는 건가?

# 6. PCB & Context Switching

## PCB(Process Control Block)이란?

- 운영체제가 프로세스를 제어하기 위해 정보를 저장해 놓는 곳으로, 프로세스의 상태 정보를 저장하는 구조체
- 프로세스 상태 관리와 문맥교환(Context Switching)을 위해 필요
- PCB는 프로세스 생성 시 만들어지며 주기억장치에 유지된다.

## PCB에서 유지되는 정보

- PID : 프로세스의 고유번호
- 상태 : 준비, 대기, 실행 등의 상태
- 포인터 : 다음 실행될 프로세스의 포인터
- Register save area : 레지스터 관련 정보
- Priority : 스케줄링 및 프로세스 우선순위
- 할당된 자원 정보
- Account : CPU 사용시간, 실제 사용된 시간
- 입출력 상태 정보

## Context Switching이란?

- CPU가 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선순위의 프로세스가 실행되어야 할 때 기존의 프로세스의 상태 (또는 레지스터 값)를 저장하고 다음 프로세스를 수행하도록 새로운 프로세스의 상태 (또는 레지스터값)를 교체하는 작업

## OverHead란?

- 과부하
- 프로세스 작업 중에는 OverHead를 감수해야하 하는 상황이 있다.
- 즉, CPU에 계속 프로세스를 수행시키도록 하기 위해 다른 프로세스를 실행시키도 Context Switching하는 것
- CPU가 놀지 않도록 만들고, 사용자에게 빠르게 일처리를 제공해주기 위한 것이다.

# 7. IPC(Inter Process Communication)

## 개념

- 내부 Process끼리 대화를 하는 것

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5d77650e-9e34-40f8-8cf4-5ae22698c82a/IPC.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5d77650e-9e34-40f8-8cf4-5ae22698c82a/IPC.png)

## 방식

1. Message Passing
   - 기존에 있던 kernel을 활용하는 것이기에 쉽게 구현할 수 있다.
   - 같은 파일을 전달하는데 있어서 conflict가 발생하지 않는다.
   - kernel의 한 구석에는 이를 저장하기 위한 공간이 필요
   - 속도도 직접 전달하는 방식에 비해서 느림
   - 매번 system call이 호출되고 이로 인한 overhead도 발생
2. Shared Memory
   - 인접한 process사이에 shared된 공간이 존재하기 때문에 system call을 부를 필요가 없다.
   - kernel에 대한 의존성이 낮다.
   - 그만큼 속도도 빠르고 communication에 대한 편의도 가져올 수 있다.
   - 생성공간에 대한 제한이 존재

# 8. CPU Scheduing

## 개념

- 메모리에 올라온 프로세스들중 어떤 프로세스를 먼저 처리할 지 일들의 순서를 정하는 일
- CPU는 한번에 한 가지 작업만 처리할 수 있음. 따라서 여러 프로그램이 번갈아 수행되돌고 스케줄링을 사용
- 스케줄링을 사용핢으로써 다중 프로그래밍이 가능해지고 CPU이용률을 극대화 시킬 수 있다.

## 종류

1. 비선점 스케쥴링

- 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링
- 프로세스가 종료되거나 자발적으로 중지되기 전까지 CPU할당을 보장하는 스케줄링
- 종류 : FIFO, SJH, 우선순위, HRN

1. 선점 스케쥴링

- 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링
- 종류 : RR, SRT, 다단계 큐